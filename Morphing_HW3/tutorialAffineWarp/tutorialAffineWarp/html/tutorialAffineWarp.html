
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN">
<html xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--
This HTML is auto-generated from an M-file.
To make changes, update the M-file and republish this document.
      -->
      <title>tutorialAffineWarp</title>
      <meta name="generator" content="MATLAB 9.0">
      <meta name="date" content="2018-02-06">
      <meta name="m-file" content="tutorialAffineWarp">
      <LINK REL="stylesheet" HREF="style.css" TYPE="text/css"><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script></head>
   <body>
      <div class="content">
         <h2>Contents</h2>
         <div>
            <ul>
               <li><a href="#3">Affine warp</a></li>
               <li><a href="#4">Example triangulation on a face image (i.e., source image)</a></li>
               <li><a href="#5">Triangulation on the warped shape  (i.e., destination shape)</a></li>
               <li><a href="#6">Calculate the warp for each triangle</a></li>
               <li><a href="#7">Calculate affine between source triangle and target triangle</a></li>
            </ul>
         </div><pre class="codeinput"><span class="keyword">function</span> tutorialAffineWarp
</pre><pre class="codeinput">close <span class="string">all</span>;
</pre><h2>Affine warp<a name="3"></a></h2>
         <h2>Example triangulation on a face image (i.e., source image)<a name="4"></a></h2><pre class="codeinput"><span class="comment">% Display input image with superimposed triangulation</span>
female = imread(<span class="string">'female.jpg'</span>);
figure;
set(gcf, <span class="string">'color'</span>,<span class="string">'w'</span>);
set(gcf, <span class="string">'Position'</span>, [0, 0, 200, 200])
imshow(female);
title(<span class="string">'Source image and triangulation'</span>);
drawnow;
<span class="comment">% Obtain triangulation</span>
tri = getTriangulationForSourceImage();

<span class="comment">% Triangle colors just to show correspondence for this tutorial</span>
triColor =  {<span class="string">'green'</span>, <span class="string">'blue'</span> };

<span class="comment">% Draw triangles superimposed on image</span>
drawTriangulation(tri, triColor);
drawnow;
</pre><img vspace="5" hspace="5" src="tutorialAffineWarp_01.png"> <h2>Triangulation on the warped shape  (i.e., destination shape)<a name="5"></a></h2><pre>This is the triangulation of the destination shape.</pre><pre class="codeinput"><span class="comment">% Target shape</span>
tri_target = getTriangulationForDestinationImage();

<span class="comment">% Display figure</span>
figure;
set(gcf, <span class="string">'color'</span>,<span class="string">'w'</span>);
title(<span class="string">'Target Shape (triangulated)'</span>);
set(gcf, <span class="string">'Position'</span>, [0, 0, 200, 200])
axis([0, 600, 0, 600])

<span class="comment">% Draw triangulation (no image to show)</span>
drawTriangulation(tri_target, triColor);
axis <span class="string">ij</span>;   <span class="comment">% Use the same coordinate system we use for image matrices.</span>
drawnow;
</pre><img vspace="5" hspace="5" src="tutorialAffineWarp_02.png"> <h2>Calculate the warp for each triangle<a name="6"></a></h2>
         <p>For each triangle in the triangulation, we estimate the affine warp which we will apply to the source image. We then extract
            the triangular regions from the transformed image, and add each region incrementally to the destination image to obtain the
            final warped image.
         </p><pre class="codeinput"><span class="comment">% Create and initialize the destination image.</span>
finalImage = uint8(zeros(600,600,3));
</pre><h2>Calculate affine between source triangle and target triangle<a name="7"></a></h2><pre class="codeinput"><span class="keyword">for</span> iTriangle = 1 : length(tri)

    <span class="comment">% Estimate the transformation between two shapes.</span>
    A = estimateAffineBetweenShapes(tri(iTriangle).x, tri(iTriangle).y, tri_target(iTriangle).x, tri_target(iTriangle).y);

    <span class="comment">% Convert our transformation matrix to matlab's own transformation format.</span>
    <span class="comment">% Matlab functions that construct tforms expect the input matrix in</span>
    <span class="comment">% transpose form.</span>
    tform = affine2d(A');

    <span class="comment">% This step applies the estimated affine warp to the source image. We</span>
    <span class="comment">% use "OutputView" to force the dimension of the transformed image to</span>
    <span class="comment">% be equal to that of the final destination image so we can just add</span>
    <span class="comment">% all the warps together (We can only add matrices of the same size).</span>
    J = imwarp(female,tform,<span class="string">'OutputView'</span>,imref2d(size(finalImage)));

    <span class="comment">% Here, we use the spatial reference information to position the</span>
    <span class="comment">% triangle on the correct location on the warped image.</span>
    figure; imshow(J);

    <span class="comment">% Plot polygon as a dashed line for visualization</span>
    hold <span class="string">on</span>;
    drawTriangle(tri_target(iTriangle).x, tri_target(iTriangle).y, triColor{iTriangle});
    title(<span class="string">'Destination triangle shape on the transformed image'</span>);
    drawnow;


    <span class="comment">% Calculate a binary mask of the region of interest - ROI (1=inside</span>
    <span class="comment">% region, 0=outside region). The ROI is created from the triangle</span>
    <span class="comment">% coordinates.</span>
    BW = roipoly(J,tri_target(iTriangle).x,tri_target(iTriangle).y);
    figure, imshow(BW);
    title(<span class="string">'Binary mask of the triangle region'</span>);
    drawnow;

    <span class="comment">% Create a 3-D mask (RGB). The original BW mask produced by the</span>
    <span class="comment">% previous step is 2-D. To mask a color image (i.e., RGB), we need a</span>
    <span class="comment">% 3-D mask.</span>
    BW3 = false(size(J,1),size(J,2),3);   <span class="comment">% We need a logical matrix</span>
    BW3(:,:,1) = BW;  <span class="comment">% Red component</span>
    BW3(:,:,2) = BW;  <span class="comment">% Green component</span>
    BW3(:,:,3) = BW;  <span class="comment">% Blue component</span>

    <span class="comment">% RGB image for storing the extracted warped region</span>
    Imasked = zeros(size(J),class(J));

    <span class="comment">% Use the 3-D mask to get the pixel values from the RGB image</span>
    Imasked(BW3) = J(BW3);   <span class="comment">% Mask works as indices for the pixels</span>

    <span class="comment">% Show the region</span>
    figure;
    imshow(Imasked);
    title( sprintf(<span class="string">'Warped Triangle %d'</span>, iTriangle) );
    drawnow;


    <span class="comment">% Increamentally add all warped triangles to form a single image with</span>
    <span class="comment">% all warped triangular regions.</span>
    finalImage = finalImage + Imasked;

    snapnow;
    drawnow;
<span class="keyword">end</span>



<span class="comment">% Show the region</span>
figure;
imshow(finalImage);
title( <span class="string">'Final Image'</span> );
drawnow;







<span class="keyword">return</span>
</pre><img vspace="5" hspace="5" src="tutorialAffineWarp_03.png"> <pre class="codeinput"><span class="keyword">function</span> drawTriangle(x, y, c)
<span class="comment">%</span>
<span class="comment">% Plot selected polygon as a dashed line for visualization</span>
hold <span class="string">on</span>;
<span class="comment">%plot(  tri(1).x, tri(1).y,'r+','LineWidth',2,'MarkerSize',10);</span>
plot(  x, y,<span class="string">'o'</span>,<span class="string">'LineWidth'</span>,2,<span class="string">'MarkerSize'</span>,10);
patch( x, y,<span class="string">'o'</span>,<span class="string">'EdgeColor'</span>,<span class="string">'k'</span>,<span class="string">'LineWidth'</span>,4,<span class="string">'MarkerSize'</span>,10,<span class="string">'FaceColor'</span>,c,<span class="string">'FaceAlpha'</span>,.2);
drawnow;

<span class="comment">% Display corner labels</span>
<span class="keyword">for</span> i = 1 : length( x )
    text( x(i)+20, y(i), <span class="keyword">...</span>
            sprintf( <span class="string">'%d'</span>, i ), <span class="string">'Color'</span>, <span class="string">'c'</span>, <span class="string">'FontSize'</span>, 16,<span class="string">'FontWeight'</span>, <span class="string">'bold'</span> );
<span class="keyword">end</span>

<span class="comment">% Force drawing now</span>
drawnow;
axis <span class="string">on</span>;


<span class="keyword">return</span>


<span class="keyword">function</span> A = estimateAffineBetweenShapes(x1, y1, x2, y2)
</pre><pre class="codeinput"><span class="comment">%</span>
<span class="comment">%  Calculates affine between mean shape 1 and shape 2.</span>
<span class="comment">%  We assume that transformation is:  A * (x1, y1, 1) = (x2, y2, 1).</span>
<span class="comment">%</span>
<span class="comment">%</span>
NumPairs = size(x1,2);    <span class="comment">% Number of pairs of points.</span>
M = zeros( 2*NumPairs, 6 );  <span class="comment">% System matrix.</span>
j = 1;
<span class="keyword">for</span> i = 1 : NumPairs         <span class="comment">% Each pair of points yields two constraints</span>
    M(j   ,:)  = [ x1(i)   y1(i)    1       0      0   0 ];
    j = j + 1;
<span class="keyword">end</span>
<span class="keyword">for</span> i = 1 : NumPairs         <span class="comment">% Each pair of points yields two constraints</span>
    M(j ,:)  = [    0      0    0    x1(i)   y1(i)   1 ];
    j = j + 1;
<span class="keyword">end</span>

M

<span class="comment">% Vector b in the least-squares equation</span>
b = [ x2'; y2' ]

<span class="comment">% Least-squares solution using matlab's \ operator</span>
a = M \ b
</pre><pre class="codeoutput">
M =

   226   240     1     0     0     0
   346   238     1     0     0     0
   380   470     1     0     0     0
     0     0     0   226   240     1
     0     0     0   346   238     1
     0     0     0   380   470     1


b =

   100
   500
   500
   200
   200
   300


a =

    3.3252
   -0.4873
 -534.5421
    0.0072
    0.4300
   95.1842

</pre><pre class="codeoutput">
M =

   226   240     1     0     0     0
   189   470     1     0     0     0
   380   470     1     0     0     0
     0     0     0   226   240     1
     0     0     0   189   470     1
     0     0     0   380   470     1


b =

   100
   100
   500
   200
   300
   300


a =

    2.0942
    0.3369
 -454.1543
   -0.0000
    0.4348
   95.6522

</pre><p>We re-construct the affine transformation matrix using the estimated values.</p><pre class="codeinput">A = [ a(1) a(2)  a(3); <span class="keyword">...</span>
      a(4) a(5)  a(6); <span class="keyword">...</span>
       0.0  0.0  1.0]


<span class="keyword">return</span>
</pre><pre class="codeoutput">
A =

    3.3252   -0.4873 -534.5421
    0.0072    0.4300   95.1842
         0         0    1.0000

</pre><img vspace="5" hspace="5" src="tutorialAffineWarp_04.png"> <img vspace="5" hspace="5" src="tutorialAffineWarp_05.png"> <img vspace="5" hspace="5" src="tutorialAffineWarp_06.png"> <pre class="codeoutput">
A =

    2.0942    0.3369 -454.1543
   -0.0000    0.4348   95.6522
         0         0    1.0000

</pre><img vspace="5" hspace="5" src="tutorialAffineWarp_07.png"> <img vspace="5" hspace="5" src="tutorialAffineWarp_08.png"> <img vspace="5" hspace="5" src="tutorialAffineWarp_09.png"> <img vspace="5" hspace="5" src="tutorialAffineWarp_10.png"> <pre class="codeinput"><span class="keyword">function</span> tri = getTriangulationForSourceImage()
<span class="comment">%</span>
<span class="comment">%  This function provides a sample triangulation.</span>
<span class="comment">%  Here, triangulation consists of only two triangles.</span>
<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">%             vertex order</span>
<span class="comment">%             1     2     3</span>
tri(1).x = [ 226   346   380 ];   <span class="comment">% Triangle 1</span>
tri(1).y = [ 240   238   470 ];

<span class="comment">%             vertex order</span>
<span class="comment">%             1     2     3</span>
tri(2).x = [ 226   189   380];   <span class="comment">% Triangle 2</span>
tri(2).y = [ 240   470   470];

<span class="keyword">return</span>


<span class="keyword">function</span> tri_target = getTriangulationForDestinationImage()
<span class="comment">%</span>
<span class="comment">%  This function provides a sample triangulation.</span>
<span class="comment">%  Here, triangulation consists of only two triangles.</span>
<span class="comment">%</span>

<span class="comment">%                  vertex order</span>
<span class="comment">%                   1     2   3</span>
tri_target(1).x = [ 100 500 500 ];   <span class="comment">% Triangle 1</span>
tri_target(1).y = [ 200 200 300 ];

<span class="comment">%                  vertex order</span>
<span class="comment">%                   1     2   3</span>
tri_target(2).x = [ 100 100 500 ];   <span class="comment">% Triangle 2</span>
tri_target(2).y = [ 200 300 300 ];


<span class="keyword">return</span>

<span class="keyword">function</span> drawTriangulation(tri, triColor)
<span class="comment">%</span>
<span class="comment">% Draws the triangulation on top of an image</span>
<span class="keyword">for</span> i = 1 : length(tri)
    drawTriangle(tri(i).x, tri(i).y, triColor{i});
<span class="keyword">end</span>

<span class="keyword">return</span>
</pre><p class="footer"><br><br></p>
      </div>
      <!--
##### SOURCE BEGIN #####
function tutorialAffineWarp


close all;
%% Affine warp
% 


%% Example triangulation on a face image (i.e., source image)
%

% Display input image with superimposed triangulation 
female = imread('female.jpg'); 
figure; 
set(gcf, 'color','w'); 
set(gcf, 'Position', [0, 0, 200, 200])
imshow(female); 
title('Source image and triangulation'); 
drawnow;
% Obtain triangulation 
tri = getTriangulationForSourceImage();

% Triangle colors just to show correspondence for this tutorial
triColor =  {'green', 'blue' }; 

% Draw triangles superimposed on image 
drawTriangulation(tri, triColor);
drawnow;

%% Triangulation on the warped shape  (i.e., destination shape)
%  This is the triangulation of the destination shape. 

% Target shape
tri_target = getTriangulationForDestinationImage();

% Display figure 
figure; 
set(gcf, 'color','w'); 
title('Target Shape (triangulated)');
set(gcf, 'Position', [0, 0, 200, 200])
axis([0, 600, 0, 600])

% Draw triangulation (no image to show) 
drawTriangulation(tri_target, triColor);
axis ij;   % Use the same coordinate system we use for image matrices. 
drawnow;
%% Calculate the warp for each triangle  
% For each triangle in the triangulation, we estimate the affine warp which
% we will apply to the source image. We then extract the triangular regions
% from the transformed image, and add each region incrementally to the
% destination image to obtain the final warped image.

% Create and initialize the destination image. 
finalImage = uint8(zeros(600,600,3));


%% Calculate affine between source triangle and target triangle
for iTriangle = 1 : length(tri)
    
    % Estimate the transformation between two shapes. 
    A = estimateAffineBetweenShapes(tri(iTriangle).x, tri(iTriangle).y, tri_target(iTriangle).x, tri_target(iTriangle).y);
            
    % Convert our transformation matrix to matlab's own transformation format.
    % Matlab functions that construct tforms expect the input matrix in
    % transpose form.
    tform = affine2d(A');
    
    % This step applies the estimated affine warp to the source image. We
    % use "OutputView" to force the dimension of the transformed image to
    % be equal to that of the final destination image so we can just add
    % all the warps together (We can only add matrices of the same size).
    J = imwarp(female,tform,'OutputView',imref2d(size(finalImage)));
    
    % Here, we use the spatial reference information to position the
    % triangle on the correct location on the warped image.
    figure; imshow(J);   
    
    % Plot polygon as a dashed line for visualization
    hold on;    
    drawTriangle(tri_target(iTriangle).x, tri_target(iTriangle).y, triColor{iTriangle});
    title('Destination triangle shape on the transformed image'); 
    drawnow;
        
    
    % Calculate a binary mask of the region of interest - ROI (1=inside
    % region, 0=outside region). The ROI is created from the triangle
    % coordinates.
    BW = roipoly(J,tri_target(iTriangle).x,tri_target(iTriangle).y);
    figure, imshow(BW);    
    title('Binary mask of the triangle region'); 
    drawnow;

    % Create a 3-D mask (RGB). The original BW mask produced by the
    % previous step is 2-D. To mask a color image (i.e., RGB), we need a
    % 3-D mask.
    BW3 = false(size(J,1),size(J,2),3);   % We need a logical matrix
    BW3(:,:,1) = BW;  % Red component 
    BW3(:,:,2) = BW;  % Green component 
    BW3(:,:,3) = BW;  % Blue component     
    
    % RGB image for storing the extracted warped region 
    Imasked = zeros(size(J),class(J));
    
    % Use the 3-D mask to get the pixel values from the RGB image 
    Imasked(BW3) = J(BW3);   % Mask works as indices for the pixels 
    
    % Show the region
    figure;
    imshow(Imasked);
    title( sprintf('Warped Triangle %d', iTriangle) );
    drawnow;
       

    % Increamentally add all warped triangles to form a single image with
    % all warped triangular regions. 
    finalImage = finalImage + Imasked;
    
    snapnow;
    drawnow;
end



% Show the region
figure;
imshow(finalImage);
title( 'Final Image' );
drawnow;







return 

function drawTriangle(x, y, c)
%
% Plot selected polygon as a dashed line for visualization
hold on;
%plot(  tri(1).x, tri(1).y,'r+','LineWidth',2,'MarkerSize',10);   
plot(  x, y,'o','LineWidth',2,'MarkerSize',10);   
patch( x, y,'o','EdgeColor','k','LineWidth',4,'MarkerSize',10,'FaceColor',c,'FaceAlpha',.2);   
drawnow;

% Display corner labels
for i = 1 : length( x )
    text( x(i)+20, y(i), ...
            sprintf( '%d', i ), 'Color', 'c', 'FontSize', 16,'FontWeight', 'bold' );
end

% Force drawing now 
drawnow;
axis on; 


return 


function A = estimateAffineBetweenShapes(x1, y1, x2, y2)
% 
%  Calculates affine between mean shape 1 and shape 2.
%  We assume that transformation is:  A * (x1, y1, 1) = (x2, y2, 1).  
%  
%
NumPairs = size(x1,2);    % Number of pairs of points.  
M = zeros( 2*NumPairs, 6 );  % System matrix. 
j = 1; 
for i = 1 : NumPairs         % Each pair of points yields two constraints
    M(j   ,:)  = [ x1(i)   y1(i)    1       0      0   0 ]; 
    j = j + 1; 
end
for i = 1 : NumPairs         % Each pair of points yields two constraints
    M(j ,:)  = [    0      0    0    x1(i)   y1(i)   1 ];
    j = j + 1; 
end

M

% Vector b in the least-squares equation
b = [ x2'; y2' ]

% Least-squares solution using matlab's \ operator
a = M \ b

%%
% We re-construct the affine transformation matrix using the estimated
% values.  
A = [ a(1) a(2)  a(3); ...
      a(4) a(5)  a(6); ...
       0.0  0.0  1.0]

   
return 


function tri = getTriangulationForSourceImage()
%
%  This function provides a sample triangulation. 
%  Here, triangulation consists of only two triangles. 
%
%
%             vertex order 
%             1     2     3
tri(1).x = [ 226   346   380 ];   % Triangle 1
tri(1).y = [ 240   238   470 ];

%             vertex order 
%             1     2     3
tri(2).x = [ 226   189   380];   % Triangle 2
tri(2).y = [ 240   470   470];

return 


function tri_target = getTriangulationForDestinationImage()
%
%  This function provides a sample triangulation. 
%  Here, triangulation consists of only two triangles. 
%

%                  vertex order 
%                   1     2   3
tri_target(1).x = [ 100 500 500 ];   % Triangle 1
tri_target(1).y = [ 200 200 300 ];

%                  vertex order 
%                   1     2   3
tri_target(2).x = [ 100 100 500 ];   % Triangle 2
tri_target(2).y = [ 200 300 300 ];


return 

function drawTriangulation(tri, triColor)
%
% Draws the triangulation on top of an image 
for i = 1 : length(tri)
    drawTriangle(tri(i).x, tri(i).y, triColor{i});
end

return 


##### SOURCE END #####
-->
   </body>
</html>