{"message":"mismatched types","code":{"code":"E0308","explanation":"\nThis error occurs when the compiler was unable to infer the concrete type of a\nvariable. It can occur for several cases, the most common of which is a\nmismatch in the expected type that the compiler inferred for a variable's\ninitializing expression, and the actual type explicitly assigned to the\nvariable.\n\nFor example:\n\n```compile_fail,E0308\nlet x: i32 = \"I am not a number!\";\n//     ~~~   ~~~~~~~~~~~~~~~~~~~~\n//      |             |\n//      |    initializing expression;\n//      |    compiler infers type `&str`\n//      |\n//    type `i32` assigned to variable `x`\n```\n"},"level":"error","spans":[{"file_name":"<::rulinalg::macros::matrix::matrix macros>","byte_start":201,"byte_end":213,"line_start":6,"line_end":6,"column_start":13,"column_end":25,"is_primary":true,"text":[{"text":"        [$ ([$ ($ x), *]), *] ; let rows = data_as_nested_array . len () ; let","highlight_start":13,"highlight_end":25}],"label":"expected an array with a fixed size of 1 element, found one with 0 elements","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/main.rs","byte_start":3355,"byte_end":3501,"line_start":134,"line_end":140,"column_start":14,"column_end":6,"is_primary":false,"text":[{"text":"    let _b = matrix![_x_prime[[0, 0]];","highlight_start":14,"highlight_end":39},{"text":"     _x_prime[[0, 1]];","highlight_start":1,"highlight_end":23},{"text":"     _x_prime[[1, 0]];","highlight_start":1,"highlight_end":23},{"text":"     _x_prime[[1, 1]];","highlight_start":1,"highlight_end":23},{"text":"     _x_prime[[2, 0]];","highlight_start":1,"highlight_end":23},{"text":"     _x_prime[[2, 1]];","highlight_start":1,"highlight_end":23},{"text":"    ];","highlight_start":1,"highlight_end":6}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"matrix!","def_site_span":{"file_name":"<::rulinalg::macros::matrix::matrix macros>","byte_start":0,"byte_end":537,"line_start":1,"line_end":12,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"() => { { use $ crate :: matrix :: Matrix ; Matrix :: new (0, 0, vec ! []) } }","highlight_start":1,"highlight_end":79},{"text":"; ($ ($ ($ x : expr), *) ; *) =>","highlight_start":1,"highlight_end":33},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        use $ crate :: matrix :: Matrix ; let data_as_nested_array =","highlight_start":1,"highlight_end":69},{"text":"        [$ ([$ ($ x), *]), *] ; let rows = data_as_nested_array . len () ; let","highlight_start":1,"highlight_end":79},{"text":"        cols = data_as_nested_array [0] . len () ; let data_as_flat_array :","highlight_start":1,"highlight_end":76},{"text":"        Vec < _ > = data_as_nested_array . into_iter () . flat_map","highlight_start":1,"highlight_end":67},{"text":"        (| row | row . into_iter ()) . cloned () . collect () ; Matrix :: new","highlight_start":1,"highlight_end":78},{"text":"        (rows, cols, data_as_flat_array)","highlight_start":1,"highlight_end":41},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected type `[i32; 1]`\n   found type `[_; 0]`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:134:14\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m134\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m    let _b = matrix![_x_prime[[0, 0]];\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m______________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m135\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m     _x_prime[[0, 1]];\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m136\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m     _x_prime[[1, 0]];\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m137\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m     _x_prime[[1, 1]];\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m138\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m     _x_prime[[2, 0]];\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m139\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m     _x_prime[[2, 1]];\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m140\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ];\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_____^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected an array with a fixed size of 1 element, found one with 0 elements\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: expected type `\u001b[0m\u001b[0m\u001b[1m[i32; 1]\u001b[0m\u001b[0m`\u001b[0m\n\u001b[0m               found type `\u001b[0m\u001b[0m\u001b[1m[_; 0]\u001b[0m\u001b[0m`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"\nThis error occurs when the compiler was unable to infer the concrete type of a\nvariable. It can occur for several cases, the most common of which is a\nmismatch in the expected type that the compiler inferred for a variable's\ninitializing expression, and the actual type explicitly assigned to the\nvariable.\n\nFor example:\n\n```compile_fail,E0308\nlet x: i32 = \"I am not a number!\";\n//     ~~~   ~~~~~~~~~~~~~~~~~~~~\n//      |             |\n//      |    initializing expression;\n//      |    compiler infers type `&str`\n//      |\n//    type `i32` assigned to variable `x`\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":3567,"byte_end":3574,"line_start":142,"line_end":142,"column_start":29,"column_end":36,"is_primary":true,"text":[{"text":"    let mut _a = utils::dot(&_m_inv, &_b);","highlight_start":29,"highlight_end":36}],"label":"expected slice, found enum `std::result::Result`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected type `&[_]`\n   found type `&std::result::Result<rulinalg::matrix::Matrix<f64>, rulinalg::error::Error>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:142:29\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m142\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let mut _a = utils::dot(&_m_inv, &_b);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected slice, found enum `std::result::Result`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: expected type `\u001b[0m\u001b[0m\u001b[1m&[_]\u001b[0m\u001b[0m`\u001b[0m\n\u001b[0m               found type `\u001b[0m\u001b[0m\u001b[1m&std::result::Result<rulinalg::matrix::Matrix<f64>, rulinalg::error::Error>\u001b[0m\u001b[0m`\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"\nThis error occurs when the compiler was unable to infer the concrete type of a\nvariable. It can occur for several cases, the most common of which is a\nmismatch in the expected type that the compiler inferred for a variable's\ninitializing expression, and the actual type explicitly assigned to the\nvariable.\n\nFor example:\n\n```compile_fail,E0308\nlet x: i32 = \"I am not a number!\";\n//     ~~~   ~~~~~~~~~~~~~~~~~~~~\n//      |             |\n//      |    initializing expression;\n//      |    compiler infers type `&str`\n//      |\n//    type `i32` assigned to variable `x`\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":3576,"byte_end":3579,"line_start":142,"line_end":142,"column_start":38,"column_end":41,"is_primary":true,"text":[{"text":"    let mut _a = utils::dot(&_m_inv, &_b);","highlight_start":38,"highlight_end":41}],"label":"expected slice, found struct `rulinalg::matrix::Matrix`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected type `&[_]`\n   found type `&rulinalg::matrix::Matrix<_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:142:38\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m142\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let mut _a = utils::dot(&_m_inv, &_b);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected slice, found struct `rulinalg::matrix::Matrix`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: expected type `\u001b[0m\u001b[0m\u001b[1m&[_]\u001b[0m\u001b[0m`\u001b[0m\n\u001b[0m               found type `\u001b[0m\u001b[0m\u001b[1m&rulinalg::matrix::Matrix<_>\u001b[0m\u001b[0m`\u001b[0m\n\n"}
{"message":"aborting due to 3 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 3 previous errors\u001b[0m\n\n"}
{"message":"For more information about this error, try `rustc --explain E0308`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about this error, try `rustc --explain E0308`.\u001b[0m\n"}
